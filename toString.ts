import type * as d from "./data.ts";
import {
  documentToString,
  typeParameterListToString,
} from "./toString/common.ts";
import { exprToString, lambdaBodyToString } from "./toString/expr.ts";
import { typeAnnotation, typeToString } from "./toString/type.ts";
import { statementListToString } from "./toString/statement.ts";
import type { Context } from "./toString/context.ts";
import denoJson from "./deno.json" with { type: "json" };

/**
 * コードを文字列にする
 */
export const moduleToString = (
  module: d.Module,
  { moduleMap, codeType }: Pick<Context, "moduleMap" | "codeType">,
  /**
   * コード生成に使用したライブラリの名前やリンク
   *
   * 指定することによって, モジュールドキュメントに出力される
   */
  generatedByLinks: ReadonlyArray<string>,
): string => {
  const context: Context = {
    moduleMap,
    usedVariableNameSet: new Set([
      ...moduleMap.values(),
      ...module.definitionList.flatMap((definition) => {
        switch (definition.type) {
          case "typeAlias":
            return [];
          case "function":
            return [definition.function.name];
          case "variable":
            return [definition.variable.name];
        }
      }),
    ]),
    usedTypeNameSet: new Set([
      ...moduleMap.values(),
      ...module.definitionList.flatMap((definition) => {
        switch (definition.type) {
          case "typeAlias":
            return [definition.typeAlias.name];
          case "function":
          case "variable":
            return [];
        }
      }),
    ]),
    codeType,
  };

  const importCode = `/** generated by
${
    [
      ...generatedByLinks,
      `https://jsr.io/@narumincho/js-ts-code-generator@${denoJson.version}`,
    ].map((link) => ` * - ${link}`).join("\n")
  }
 * Do not edit!
 *
 * @module
*/

` +
    [...moduleMap.entries()]
      .map(
        ([name, identifier]) =>
          "import * as " + identifier + ' from "' + name + '";',
      )
      .join("\n") +
    "\n";

  const definitionCode = module.definitionList
    .map((definition) => definitionToString(definition, context))
    .join("") + "\n";

  const statementCode = statementListToString(
    module.statementList,
    0,
    context,
  );

  if (module.statementList.length === 0) {
    return importCode + definitionCode;
  }
  return importCode + definitionCode + statementCode;
};

const definitionToString = (
  definition: d.Definition,
  context: Context,
): string => {
  switch (definition.type) {
    case "typeAlias":
      if (context.codeType === "JavaScript") {
        return "";
      }
      return typeAliasToString(definition.typeAlias, context);

    case "function":
      return exportFunctionToString(definition.function, context);

    case "variable":
      return exportVariableToString(definition.variable, context);
  }
};

const typeAliasToString = (
  typeAlias: d.TypeAlias,
  context: Context,
): string => {
  const content = documentToString(typeAlias.document) +
    (typeAlias.export ? "export " : "") +
    "type " +
    typeAlias.name +
    typeParameterListToString(typeAlias.typeParameterList, context) +
    " = " +
    typeToString(typeAlias.type, context) +
    ";\n\n";
  if (typeAlias.namespace.length === 0) {
    return content;
  }
  return (
    "export declare namespace " +
    typeAlias.namespace.join(".") +
    " {\n" +
    content +
    "\n}"
  );
};

const exportFunctionToString = (
  function_: d.FunctionDefinition,
  context: Context,
): string =>
  documentToString(
    function_.document + parameterListToDocument(function_.parameterList),
  ) +
  (function_.export ? "export " : "") +
  "const " +
  function_.name +
  " = " +
  (function_.isAsync ? "async " : "") +
  typeParameterListToString(function_.typeParameterList, context) +
  "(" +
  function_.parameterList
    .map(
      (parameter) => parameter.name + typeAnnotation(parameter.type, context),
    )
    .join(", ") +
  ")" +
  (function_.returnType ? typeAnnotation(function_.returnType, context) : "") +
  " => " +
  lambdaBodyToString(function_.statementList, 0, context) +
  ";\n\n";

const exportVariableToString = (
  variable: d.VariableDefinition,
  context: Context,
): string =>
  documentToString(variable.document) +
  (variable.export ? "export " : "") +
  "const " +
  variable.name +
  (variable.type === undefined ? "" : typeAnnotation(variable.type, context)) +
  " = " +
  exprToString(variable.expr, 0, context) +
  ";\n\n";

const parameterListToDocument = (
  parameterList: ReadonlyArray<d.ParameterWithDocument>,
): string =>
  parameterList.length === 0 ? "" : "\n" +
    parameterList
      .map((parameter) =>
        parameter.document === ""
          ? ""
          : "@param " + parameter.name + " " + parameter.document
      )
      .join("\n");
